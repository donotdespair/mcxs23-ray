---
title: "Effects of Fiscal Policy on Unemployment and Output in Australia: a Bayesian SVAR Approach"
author: "Ray Gomez"

execute:
  echo: false
  
bibliography: references.bib
---

> **Abstract.** This proposed study attempts to estimate the effects of various fiscal policy instruments on unemployment and output in Australia, using a Bayesian Structural Vector Autoregression approach. Impulse response functions and forecast variance error decomposition methods are expected to be used for measuring these effects. This study also compares two model specifications -- a basic model with unempolyment, output, fiscal policy, and monetary policy variables; and an extended model which also models heteroskedasticity due to the COVID-19 pandemic. 
>
> **Keywords.** Fiscal policy, unemployment, GDP, Australia impulse response, forecast variance error decomposition, bsvars, R

## Introduction

In many countries, fiscal policy is viewed as a direct means of achieving inclusive development objectives, frequently articulated as twin goals of sustained growth and low poverty (often achieved through low unemployment). However, fiscal policy shocks often occur in multifaceted ways, with simultaneous changes in both revenue and expenditure-side elements of the fiscal balance, making it difficult to disentangle the effects of any one particular policy shock.

This study attempts to identify the effect of the following fiscal policy instruments: tax policy, public investment expenditures, and social transfers, on both unemployment and output in the Australian context, using a Bayesian Structural Vector Autoregression (BSVAR) approach.

The analysis is guided by the work of @abubakar2016dynamic, which used an SVAR approach to estimate the effect of public expenditures and public revenues on Nigerian output and unemployment. This study extends his work by using a more extensive dataset, containing more disaggregated revenue and expenditure variables, the inclusion of monetary policy control variables, as well as through the use of Bayesian estimation.

## Data sources

Quarterly data from Q1 1990 to Q4 2022 was sourced from the Australian Bureau of Statistics (ABS) and the Reserve Bank of Australia (RBA) and extracted using the `readabs` and `readrba` packages in `R`.

Unemployment rate and nominal GDP data are viewed as the outcome variables while tax revenue, public gross fixed capital formation (i.e., public investment) and government social assistance payments (i.e., social subsidies) are the explanatory variables of interest. Government final consumption is included to control for the effects of less productive, more routine government spending. Lastly, non-tax revenue (which, arguably, have a less distortionary effect on markets compared to taxes) and monetary policy reflected through the cash rate target and M3 money supply are also controlled for to mitigate omitted variable issues.

Outcome variables:

-   Unemployment rate and nominal GDP

Explanatory variables of interest

-   Revenue: Tax revenue

-   Spending: Public gross fixed capital formation and social assistance payments

Control variables:

-   Other fiscal policies: non-tax (gross income less tax) revenue, government final consumption
-   Monetary policy: cash rate target and M3 money supply
-   External sector: real exchange rate

```{r set up and libraries, include = F}
rm(list=ls())
library(readrba)
library(readabs)
library(xts)
library(tseries)
library(urca)
library(FinTS)
library(rmarkdown)
library(corrplot)
library(parallel)
```

```{r data download, include = F}
#| message: false
#rba <- browse_rba_series(search_string = "")
#abs <- as.matrix(show_available_catalogues())
#remotes::install_github("mattcowgill/readrba")

## Monetary policy variables
# Cash interest rate
cash_rate.dl   <- read_rba(series_id = "FIRMMCRTD")
cashrate <- to.quarterly(xts(cash_rate.dl$value, cash_rate.dl$date), 
                         OHLC = FALSE)
# M3 Money supply
M3.dl   <- read_rba(series_id = "DMAM3N")
M3 <- to.quarterly(xts(M3.dl$value, M3.dl$date), 
                         OHLC = FALSE)

# real exchange rate (TWI)
# realTWI.dl   <- read_rba(series_id = "FRERTWI")
# realTWI <- to.quarterly(xts(realTWI.dl$value, realTWI.dl$date), 
                         # OHLC = FALSE)

# Unemployment rate: A84423092X
unemp_rate.dl <- read_abs(series_id = "A84423092X")
unemp <- to.quarterly(xts(unemp_rate.dl$value, unemp_rate.dl$date), 
                           OHLC = FALSE)

# real GDP: A2302459A
realGDP.dl   <- read_abs(series_id = "A2302459A")
realGDP <- to.quarterly(xts(realGDP.dl$value, realGDP.dl$date), 
                         OHLC = FALSE)

# Nominal GDP: A2302467A
# nomGDP.dl <- read_abs(series_id = "A2302467A")
# nomGDP <- to.quarterly(xts(nomGDP.dl$value, nomGDP.dl$date), 
#                          OHLC = FALSE)

#summary(unemp_rate)
## Fiscal variables
# Total tax: A2301963V
totaltax.dl <- read_abs(series_id = "A2301963V")
totaltax <- to.quarterly(xts(totaltax.dl$value, totaltax.dl$date), 
                         OHLC = FALSE)
# Non-tax revenue: Gross income (A2302106V) - total tax 
govgrossinc.dl <- read_abs(series_id = "A2302106V")
govgrossinc <- to.quarterly(xts(govgrossinc.dl$value, govgrossinc.dl$date), 
                         OHLC = FALSE)
nontax <- govgrossinc - totaltax

# Public gross fixed capital formation: A2302555A
pubinv.dl <- read_abs(series_id = "A2302555A")
pubinv <- to.quarterly(xts(pubinv.dl$value, pubinv.dl$date), 
                         OHLC = FALSE)

# Social assistance benefits payments: A2301976F
pubtrans.dl <- read_abs(series_id = "A2301976F")
pubtrans <- to.quarterly(xts(pubtrans.dl$value, pubtrans.dl$date), 
                         OHLC = FALSE)
# Government final consumption: A2302527T
pubcons.dl <- read_abs(series_id = "A2302527T")
pubcons <- to.quarterly(xts(pubcons.dl$value, pubcons.dl$date),
                         OHLC = FALSE)

```

##### Table 1. Data from ABS and RBA {style="text-align: center;"}

```{r data merge and log transform, echo = F}
# Merge data into one matrix
Y.df  <- na.omit(merge(unemp, realGDP , totaltax, nontax, pubinv, 
                       pubtrans, pubcons, cashrate, M3))

varname_vec <- c("Unemployment rate", "Real GDP", "Tax revenue", "Non-tax revenue", "Gov't GFCF",
                    "Social benefits payments", "Gov't consumption", "Cash rate target", "M3 supply")
colnames(Y.df) <- varname_vec

Y.df <- Y.df[1:132,]
# Transform into natural logs
lnY.df <- log(Y.df)

date <- as.vector(index(cashrate))[1:132]
T <- length(date)

paged_table(as.data.frame(round(head(lnY.df,4),2)))
paged_table(as.data.frame(round(tail(lnY.df,4),2)))

# data for input to estimation function 
lnY.df_num <- c()

for (i in 1:ncol(lnY.df)){
  lnY.df_num <- cbind(lnY.df_num, as.numeric(lnY.df[,i]))
}

```

# 

As seen in the figures below, Australian GDP output has been on a relatively steady, upward trend since 1990, along with fiscal revenue and spending. These have, by and large, been accommodated by declining interest rates and an expanding money supply. Overall, these have been associated with a downward, albeit volatile trajectory in the unemployment rate. Currently, the data is left in original, seasonally-unadjusted form as the variable for social benefit payments does not have a seasonally-adjusted version in the ABS website. As such, some seasonal variation between quarters can be observed in time series plots. However, the final version of the data to be used will be determined after further exploration. Lastly, the data will be transformed into natural log terms during the analysis as to interpret the coefficients in the structural matrix as elasticities.

##### Figure 1. Time series plots: 1990 Q1 to 2022 Q4, original values {style="text-align: center;"}

```{r, echo = F}
colvec <- c("turquoise4","turquoise4", "plum4", "plum4", "plum4", "plum4", "plum4","firebrick3","firebrick3")
par(mfrow=c(3,3), mar=c(2,2,2,2))
for (i in 1:9){
  plot(date, y = Y.df[,i], type = "l", 
       main = paste(varname_vec[i]), ylab = "", xlab = "",
       col = colvec[i], lwd = 1.5,
       ylim = c(min(Y.df[,i]),max(Y.df[,i])))
}

```

## Preliminary data analysis

### ACF and PACF analysis

Across variables (which have been transformed into natural log terms), ACF plots show a strong, positive, and gradually decaying autocorrelation structure. Moreover various PACF plots indicate a near-one value at the first lag and much lower, mostly statistically zero values at higher lag orders (such as in nominal GDP, social benefits payments, government consumption, and M3). These characteristics may indicate that some variables may be following a random walk with drift process and as such may be unit-root non-stationary.

###### Figure 2.1. Autocorrelation function (ACF) plots of variables in log terms {style="text-align: center;"}

```{r ACF plots, echo = FALSE}
par(mfrow=c(3,3), mar=c(2,2,2,2))
for (i in 1:9){
  Acf(lnY.df[,i], main = "", ylim = c(-0.2,1))
  title(main = paste(varname_vec[i]), line = 0.5)
} 
```

###### Figure 2.2. Partial autocorrelation function (PACF) plots of variables in log terms {style="text-align: center;"}

```{r PACF plotsPACF analysis, echo = FALSE}
par(mfrow=c(3,3), mar=c(2,2,2,2))
for (i in 1:9){
  pacf(lnY.df[,i], main = "", ylim = c(-0.2,1))
  title(main = paste(varname_vec[i]), line = 0.5)
} 

```

### Augmented Dickey-Fuller test for unit roots

```{r Ng-Perron ADF test function, echo = TRUE}
# function to implement the Ng and Perron (1998) ADF test procedure
ngperronADF <- function(y){
  T <- length(y)
  kmax <- ceiling(12*(((T-25)/100)^(1/4)))
  k <- kmax + 1
  # run test regression until t-statistic of kth lag > 1.6
  t <- 0
  while(abs(t) < 1.6){
      k <- k - 1
      adft <- ur.df(y, type = "drift", lags = k)
      t <- as.numeric(adft@testreg$coefficients[k+2,][3])
  }
  adft_k <-ur.df(y, type = "drift", lags = k)
  teststat <- adft_k@teststat[2]
  cval <- adft_k@cval[2,2]
  sig <- abs(teststat)>abs(cval)
  return(list("stat" = teststat,"crit" = cval,"reject" = sig))
}

```

##### Table 2. ADF test results: levels, first, and second difference {style="text-align: center;"}

```{r ADF test and order of integration determination, echo = FALSE}

adf_results_lev <- c()
adf_results_fd <- c()
adf_results_fd2 <- c()

for (i in 1:9){
npadf_lev <- ngperronADF(lnY.df[,i])  
npadf_fd <- ngperronADF(diff(lnY.df[,i])[-1]) 
npadf_fd2 <- ngperronADF(diff(diff(lnY.df[,i])[-1])[-1]) 


adf_results_lev <- round(rbind(adf_results_lev,c(npadf_lev[[1]],
                                           npadf_lev[[3]])),2)

adf_results_fd <- round(rbind(adf_results_fd,c(npadf_fd[[1]],
                                         npadf_fd[[3]])),2)
adf_results_fd2 <- round(rbind(adf_results_fd2,c(npadf_fd2[[1]],
                                        npadf_fd2[[3]])),2)
}

colnames(adf_results_lev) <- c("ADF statistic, levels", "Reject?")
colnames(adf_results_fd) <- c("ADF statistic, 1st difference", "Reject?")
colnames(adf_results_fd2) <- c("ADF statistic, 2nd difference", "Reject?")

rownames(adf_results_lev) <- varname_vec
rownames(adf_results_fd) <- varname_vec
rownames(adf_results_fd2) <- varname_vec

adf_results <- cbind(adf_results_lev,adf_results_fd, adf_results_fd2)

paged_table(as.data.frame(adf_results))


for (i in 1:9){
npadf_lev <- ngperronADF(lnY.df[,i])  
#npadf_fd <- ngperronADF(diff(lnY.df[,i])[-1]p)  
}
```

# 

Augmented Dickey-Fuller tests following the maximum lag-setting procedure of Ng and Perron (1998) were performed on all nine variables to determine stationarity and orders of integration. The null hypothesis that a unit roots exists was rejected for ADF tests on levels of tax revenue, non-tax revenue, social benefits payments, government consumption, and M3 supply, indicating that these variables do not have a unit-root, and may be following trend-stationary autoregressive processes. Meanwhile, the first differences of the unemployment rate, government GFCF, and cash rate target variables yielded a significant ADF test result, indicating that these have order of integration of 1. Lastly, it took another differencing for nominal GDP to yield a significant result, indicating an order of integration of 2. Further analysis of these variables, including a better-calibrated ADF test and cointegration tests will be performed in the future.

## Model specification

The use of fiscal policy to stimulate or regulate the economy follows the Keynesian approach generally practiced around the world (but especially in developing countries) to navigate economies through downturns or potential episodes of overheating, particularly in the short-run. The proposed model aims to investigate the effectiveness of these fiscal measures in managing growth and unemployment.

### Structural form (SF) model

The following SVAR model specification is proposed is to represent the system through which the included variables are jointly determined:

$$
\begin{align}
B_0y_t &= b_0 + B_1 y_{t-1} + \dots + B_p y_{t-p} + u_t\\
u_{t}| Y_{t-1} &\sim _{iid} ( 0, I_N)
\end{align}
$$ where $y_t$ is a vector of endogenous variables:

$$y_t=\begin{pmatrix} unemp_t &= \text{unemployment rate}
\\ realgdp_t &= \text{real GDP}
\\ totaltax_t  &= \text{tax revenue}
\\ nontax_t  &= \text{non-tax revenue}
\\ pubinv_t  &= \text{government gross fixed capital formation}
\\ pubtrans_t  &= \text{social assitance and benefits payments}
\\ pubcons_t  &= \text{government final consumption}
\\ cashrate_t  &= \text{cash rate target}
\\ M3_t  &= \text{M3 money supply}
\end{pmatrix}$$

and the structural matrix $B_0$ summarizes the contemporaneous relationships between these variables.

### Reduced form (RF) model

$$
\begin{align}
y_t &= \mu_0 + A_1 y_{t-1} + \dots + A_p y_{t-p} + \varepsilon_t\\
\text{where }B_0^{-1}u_t &= \varepsilon_t| Y_{t-1} \sim _{iid} ( 0, \Sigma)\\
\Sigma &= B_0^{-1}B_0^{-1'}
\end{align}
$$

The reduced form of the model, where $B_0^{-1}$ is the matrix of contemporaneous effects between variables, allows for model estimation. However, the identification strategy for $B_0^{-1}$ is yet to be finalized, but will likely involve either exclusion restrictions or sign restrictions.

The study will utilize impulse response functions (IRF) and forecast error variance decomposition (FEVD) methods to measure the effects of the tax policy, public investment, and government social transfers on the unemployment rate and GDP output. IRFs are used to measure the dynamic, marginal effects of orthogonal shocks from the three fiscal levers of interest while FEVD intends to account for the share of explained variability in the outcome variables that can be attributed to explanatory variables of interest.



```{r Basic model estimation function}
# data = input data should be quarterly
# p = lags
# S = number of posterior draws
# sign restritions = Nx1 diagonal of R matrix
# k1 = kappa1
# k2 = kappa2, higher value, less shrinkage, more weight on prior
# start date = start date of Y matrix
sign_est.basic <- function(data, p, S,  sign.restrictions,
                           k1=0.2^2, k2=100, start_date = c(1991,1)){
  # Define Y and X matrices
  ############################################################
  # N = no. of variables
  N = ncol(data)
  # p = no. of lags
  K = 1 + p*N
  # forecast horizon
  # h       = 8
  
  Y       = ts(data[5:nrow(data),], start=start_date, frequency=4)
  X       = matrix(1,nrow(Y),1)
  # nrow(X)
  for (i in 1:p){
    X     = cbind(X,data[5:nrow(data)-i,])
  }
  
  #t0          = proc.time() # read processor time
  
  # Calculate MLE
  ############################################################
  A.hat       = solve(t(X)%*%X)%*%t(X)%*%Y
  Sigma.hat   = t(Y-X%*%A.hat)%*%(Y-X%*%A.hat)/nrow(Y)
  # round(A.hat,3)
  # round(Sigma.hat,3)
  # round(cov2cor(Sigma.hat),3)
  
  # Specify prior distribution
  ############################################################
  kappa.1     = k1
  kappa.2     = k2
  kappa.3     = 1
  A.prior     = matrix(0,nrow(A.hat),ncol(A.hat))
  A.prior[2:(N+1),] = kappa.3*diag(N)
  V.prior     = diag(c(kappa.2,kappa.1*((1:p)^(-2))%x%rep(1,N)))
  S.prior     = diag(diag(Sigma.hat))
  nu.prior    = N+1
  
  # normal-inverse Wishard posterior parameters
  ############################################################
  V.bar.inv   = t(X)%*%X + diag(1/diag(V.prior))
  V.bar       = solve(V.bar.inv)
  A.bar       = V.bar%*%(t(X)%*%Y + diag(1/diag(V.prior))%*%A.prior)
  nu.bar      = nrow(Y) + nu.prior
  S.bar       = S.prior + t(Y)%*%Y + t(A.prior)%*%diag(1/diag(V.prior))%*%A.prior - t(A.bar)%*%V.bar.inv%*%A.bar
  S.bar.inv   = solve(S.bar)
  
  # posterior draws 
  ############################################################
  ## draw from RF posterior
  # draw Sigma from inverse wishart
  Sigma.posterior   = rWishart(S, df=nu.bar, Sigma=S.bar.inv)
  Sigma.posterior   = apply(Sigma.posterior,3,solve)
  Sigma.posterior   = array(Sigma.posterior,c(N,N,S))
  
  # draw A from matrix-variate normal
  A.posterior       = array(rnorm(prod(c(dim(A.bar),S))),c(dim(A.bar),S))
  
  ## draw from SF posterior
  B.posterior       = array(NA,c(N,N,S))
  Bplus.posterior       = array(NA,c(N,K,S))
  L                 = t(chol(V.bar))
  for (s in 1:S){
    # Draw B0
    cholSigma.s     = chol(Sigma.posterior[,,s])
    B.posterior[,,s]= t(cholSigma.s)
    A.posterior[,,s]= A.bar + L%*%A.posterior[,,s]%*%cholSigma.s
    # Draw Bplus
    Bplus.posterior[,,s] = B.posterior[,,s]%*%t(A.posterior[,,s])
  }
  # round(apply(A.posterior,1:2,mean),4)
  # round(apply(B.posterior,1:2,mean),4)
  
  # Identification via sign restrictions on theta0
  ############################################################
  # should have N elements
  #sign.restrictions = c()
  
  # generate corresponding R matrix
  R1 = diag(sign.restrictions)
  
  # storage matrices for Q identified estimates
  i.vec <- c()
  Q.iden   = array(NA,c(N,N,S))
  B0.iden = array(NA,c(N,N,S))
  B1.iden = array(NA,c(N,K,S))
  A.iden = array (NA,c(K,N,S))
  
  pb = txtProgressBar(min = 0, max = S, initial = 0) 

  for (s in 1:S){
    
    setTxtProgressBar(pb,s)
    #cat(". iteration: ", s, "\n")
    
    # pick-up a B0 from S
    B0.tilde <- B.posterior[,,s]
    IR.0.tilde    = solve(B0.tilde)
    B1.tilde      = Bplus.posterior[,,s]
    #IR.1.tilde    = solve(B0.tilde)%*%B1.tilde%*%solve(B0.tilde)

    # Search for appropriate Q 
    sign.restrictions.do.not.hold = TRUE
    i=1
    while (sign.restrictions.do.not.hold){
      X           = matrix(rnorm(N^2),N,N)
      QR          = qr(X, tol = 1e-10)
      Q           = qr.Q(QR,complete=TRUE)
      R           = qr.R(QR,complete=TRUE)
      Q           = t(Q %*% diag(sign(diag(R))))
      B0          = Q%*%B0.tilde
      B1          = Q%*%B1.tilde
      B0.inv      = solve(B0)
      check       = prod(R1 %*% B0.inv %*% diag(N)[,1] > 0)
      A           = t(solve(B0)%*%B1)

      if (check==1){sign.restrictions.do.not.hold=FALSE}
      i=i+1
    }
    i.vec <- c(i.vec, i)
    Q.iden[,,s] <- Q
    B0.iden[,,s] <- B0
    B0.mean <- apply(B0.iden,1:2,mean)
    B1.iden[,,s] <- B1
    B1.mean <- apply(B1.iden,1:2,mean)
    A.iden[,,s] <- A
    A.mean <- apply(A.iden,1:2,mean)
    

  }
  re <- list("i" = i.vec, "Q" = Q.iden, "B0"= B0.iden, "B0.mean" = B0.mean,
             "Bplus"= B1.iden, "Bplus.mean" = B1.mean, "A" = A.iden, "A.mean" = A,
             "A.posterior"=A.posterior, "Sigma.posterior"=Sigma.posterior)
  return(re)
}

```

```{r RW sample}

set.seed(1)

y1 <- arima.sim(model= list(order = c(0, 1, 0)), n=1000, mean=0, sd=1)
y2 <- arima.sim(model= list(order = c(0, 1, 0)), n=1000, mean=0, sd=1)
#y1 <- cumsum(rnorm(1000, 0, sd=1))
#y2 <- cumsum(rnorm(1000, 0, sd=1)) 
#y3 <- cumsum(rnorm(1000, 0, sd=1)) 

y <- cbind(y1,y2)

par(mfrow=c(1,2))
plot(y[,1], type = "l", col = "dodgerblue3")
plot(y[,2], type = "l", col = "firebrick3")
#plot(y[,3], type = "l", col = "darkorchid3")


# numCores <- detectCores()
# numCores
# 
# cl <- makeCluster(numCores)
# stopCluster(cl)
#set.seed(1)
#RW_res <-  sign_est.basic(data=y, p=1, S=5000, c(1,1), k1 = 1^2, k2 = 100)
#RW_res$A.mean

#apply(RW_res2$A.posterior,1:2,mean)
#apply(RW_res2$Sigma.posterior,1:2,mean)
#A.posterior[,,1]
# B0 <- diag(2)
# B1 <- cbind(c(0,0),diag(2))
# t(solve(B0)%*%B0%*%B1)

#dim(RW_res$A.mean)


basic_mod <- sign_est.basic(lnY.df_num,p=4,S=50000,c(-1, 1, 1, 1, 1, 1,-1, 1, -1))
#basic$i
#basic$Q
#basic$B0
#basic$B0.mean

#solve(RW_res$B0.mean)%*%RW_res$B0.mean%*%RW_res$B1.mean
#basic_mod <- sign_est.basic(lnY.df_num,4,100,c(-1, -1, 1, -1, -1, 1,-1, 1, -1))



```




## References
